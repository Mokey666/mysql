- 

- ## 数据库

- ### MySQL逻辑框架

  - ![img](https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617123859211-1860022440.png)

  -  第一层：并不是mysql独有的，一般的c/s程序，包括：连接处理、验证身份、安全性等

  - 第二层：mysql核心部分，大部分mysql服务都在这一层，查询解析、分析、优化、缓存以及所有的内置函数；所有的跨存储引擎功能都在这一层
  - 第三层：存储引擎。服务器通过API于存储引擎进行通信，不同的存储引擎之间不会通信，只是简单地相应服务器的请求。

- mysql逻辑模块组成

  - ![img](https://images2018.cnblogs.com/blog/1411859/201806/1411859-20180617124155105-273948974.png)

  - 数据库驱动：Druid 用于连接数据库

  - 数据库连接池：管理数据库实例

  - 管理服务和工具组件：系统管理和控制工具

  - SQL 接口组件：接受用户的SQL语句，并且返回用户需要查询的结果

  - 解析器（Parse）：SQL命令传递到解析器的时候会被解析器验证和解析，是个脚本

  - 查询优化器：SQL语句在查询之前会使用查询优化器对查询进行优

  - 缓冲组件：查询缓存

  - 插件式存储引擎：存储引擎是基于表的，不是基于数据库的

    

- ### 并发控制

  - 锁：都是存储引擎实现的，不是服务器端。

  - 读写锁：允许多读、单写（读是共享锁、写是排他锁）
  - 锁粒度
    - 表锁：最小开销策略，锁住整张表，一个用户在对表进行（增加、删除、更新）操作时，先获取写锁、并阻挡其它用户获取写锁。
    - 行锁：最大程度的支持并发处理(同时带来最大程度的锁开销)，锁住行（一条记录）。
  - 并发问题
    - 更新丢失：当两个事务同时更新一条数据，就有可能一方的更新数据覆盖另一方。
    - 脏读：一个事务能读取到另一个事务未提交之前所修改后的数据。
    - 幻读：就是一个事务在读取一个范围的数据时，另一个事务往其中插入一条数据，当第一个事务再次读取数据时会有一条新的数据（另一个事务插入的数据）。
    - 不可重复读：就是一个事务对一条数据读取两遍，第二次读的时候发现别的事务对他进行了修改。

- ### 事务

  - 四个特性：

  - 原子性：最小的工作单元，一个事务要么所有操作成功提交，要么就失败全部回滚到开始之前的状态。

  - 一致性：数据库总是从一个一致性状态转换到另一个一致性状态。

  - 隔离性：通常来说，一个事务在提交之前的所有操作，其他事务不可见。

  - 持久性：一旦事务提交，其修改的操作就永久的保存在数据库中，就算系统崩溃都修改的数据都不会消失。

    - 隔离的四个级别：

      - ### 未提交读（read-uncommitted）：

        事务的修改即便没有提交，对其他事务也是可见的。这种行为叫做”脏读“

      - ### 已提交读（read-committed）：

        一个事务开始时。只能”看见“已提交的事务所作的修改，也叫做不可重复读

      - ### 可重复读（repetable-read）：

        把证在同一事务中多次读取同样记录的结果是一样的，但是有可能发生“幻读”

      - ### 可串行化（serializable）：

        它强制事务串行化，避免了"幻读"，简单的来说它会在读取的每行数据上加锁

- ### 数据库设计

  - 第一范式（1NF）

    - 第一范式，强调属性的原子性约束，要求属性具有原子性，不可再分解.

  - 第二范式（2NF）

    - 第二范式，强调记录的唯一性约束，表必须有一个主键，并且没有包含在主键中的列必须完全依赖于主键，而不能只依赖于主键的一部分。 
    - 例子：假如有两个字段（A,B）是主键，字段(C,D)分别依赖于（A,B）所以导致只依赖于部分主键，不符合第二范式。

  - 第三范式（3NF）

    - 第三范式，强调属性冗余性的约束，即非主键列必须直接依赖于主键。
    - 例子：假如字段A,B,C  A为主键，B依赖于A，C依赖于B，导致C不直接依赖于主键A，所以不满足第三范式。

  - 反范式（反模式）

    - 范式可以避免数据冗余，减少数据库的空间，减轻维护数据完整性的麻烦。
    - 反范式会产生冗余。

  - 范式和反范式的优缺点

    - 范式
      - 优点：
        1. 范式的更新操作通常比反范式快
        2. 当数据较好的范式化，就很少有重复的数据，所以只需要更改更少的数据。
        3. 范式表通常很小，占内存不大，执行操作更快
        4. 很少有多余的数据。例如：范式表查询的数据刚好都需要，而反范式差距的表数据或许有很多多余的字段。
      - 缺点：
        1. 通常需要表的关联，稍微复杂的操作就需要代价非常大，还有可能使一些索引策略无效。
    - 反范式
      - 优点：很好的避免关联
      - 缺点：很好的别面关联意味着大部分查询情况都是最差的，不使用索引查询，直接全表扫描

  - 实际

    一般都是范式和反范式混合使用。

- ### 死锁

  - 是指两个或多个事务在同一资源上相互占用，并请求锁定对方所占用的资源。

  - 一般数据库处理死锁问题：死锁检测和死锁超时机制。InnoDB存储引擎处理死锁的方法是：

    将持有最少行级排他锁的事务进行回滚

- ### 事务日志

- ### 多版本并发控制（MVCC）

  - 是一种用来**解决读-写冲突**的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 这样在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。
  
  - MVCC的实现
  
    - MVCC是通过保存数据在某个时间点的快照来实现的. 不同存储引擎的MVCC. 不同存储引擎的MVCC实现是不同的,典型的有乐观并发控制和悲观并发控制. 
  
  - 具体实现
  
    - InnoDB的MVCC,是通过在每行记录后面保存两个隐藏的列来实现的,这两个列，分别保存了这个行的创建时间，一个保存的是行的删除时间。这里存储的并不是实际的时间值,而是系统版本号(可以理解为事务的ID)，没开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID.
  
    - 简单的说他会为每行数据创建隐藏两个字段值（创建时间、销毁时间），即每张表都会有这两个字段。
  
      前提：创建时间=事务ID， 销毁时间=事务ID（形象的比喻）
  
      一个事务只会检索创建时间（事务ID）比它小或者等于的数据行；还有销毁时间（事务ID）比他大的数据行。
  
      例：![1567414040607](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567414040607.png)
  
      ![1567414520375](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567414520375.png)
  
      当事务1 执行插入语句：
  
      第一次
  
      insert into 表名 values（NULL，‘yang’）
  
      insert into 表名 values（NULL，‘long’）
  
      insert into 表名 values（NULL，‘fei’）
  
      
  
      事务2 执行查找语句
  
      情况1：在事务1之后 执行：select ‘yang’ from  表名
  
      情况2：在事务1之后，事务3之前 ： select ‘tian’ from  表名
  
      
  
      事务3 在事务2 执行过程中，执行插入语句
  
      insert into 表名 values（NULL，‘tian’）
  
      情况1：由于前3条记录的创建时间小于事务2，所以事务2 能查询到。
  
      情况2：由于第四条记录的创建时间大于事务2，所以事务2 查询不到
  
- ### Mysql的存储引擎

   详情请看InnoDB引擎详解
   
   - 如何选择合适的存储引擎
     - 事务：是否支持事务
     - 备份：如果定期的关闭服务器来执行备份，那么可以忽略；若果需要在线热备份，选择InnoDB
     - 崩溃恢复：当系统崩溃时，是否能快速的恢复大量数据
     - 一些存储引擎特有的特性
     - 对索引和缓存的支持
     - 外键的支持
     - 存储的限制
   - 转换存储引擎
     - ALTER TABLE
       - 例：ALTER TABLE  表明  ENGINE = InnoDB
     - 导入和导出
     - 创建与查询（CREAT 和 SELECT）
   
- ### Mysql数据类型

  - 如何选择最好的数据类型
    - 更小的通常更好：更小的数据类型通常更快，因为他们占用更少的磁盘，内存和CPU缓存。
    - 简单就好：简单的数据类型通常需要更少的CPU周期。
    - 尽量避免NULL：NULL的列对于Mysql更难优化，通常NULL列会使用更多的存储空间，也会被特殊处理
    - 在为列选择数据类型时：先选大类型（时间 字符串 数字），再选小类型
  - 数据类型
    - 整数类型
      - TINYINT、SMALLINT、MEDIUMINT、INT 、BIGINT。分别是8、16、24、32、64位存储空间。
      - 整数类型有UNSIGNED属性，表示不能有负数，这样可以使正数个数上限提高一倍
    - 实数类型
      - DECIMAL、FOLAT、DOUBLE。
    - 字符串类型
      - CHAR、VACHAR
        - CHAR：固定长度字符串，会自动删除字符串末尾的“空格”，适合用于存储字符串长度相同的值（MD5加密密码，或者较短的字符串。
        - VACHAR：可变长字符串，但是需要1或2个额外的字节，记录字符串的长度。例如VACHAR(10)，他就需要11个字节； VACHAR(1000)他就需要1002个字节
      - BLOB、TEXT
        - 都是位存储和大数据（字符串）而设计的，分别采用二进制和字符方式存储。
        - 两者的区别：BLOB用二进制存储、没有排序规则；TEXT字符存储、有排序规则
  - 枚举类型
    - 就是个枚举类型

  - SET类型
    - 集合（变相的枚举）。
  - 时间/日期类型

  - 注意：小心使用枚举和集合，否则会变成“陷阱”，最好不适用BIT ----陷阱是什么需要你自己去了解

- ### 索引

  - 索引是什么---相当于书的“目录”

    

  - B-tree索引（从技术讲是B+tree）

    - ![1567587480579](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567587480579.png)
    - 只有叶子节点（叶子页）指向被索引的数据
    - 直接是个顺寻结构。
    - 索引对如下查询有效
      - 全值查询
      - 匹配最左前缀：key（a，b，c）可以根据a来查找，即根据索引最左边的列来查询。
      - 匹配列前缀：对于匹配的列，可以进行类似于”模糊查询“。
      - 匹配范围值
      - 精确匹配某一列并范围匹配另外一列
      - 只访问索引的查询
    - 关于B-tree的限制
      - 如果不是按照索引最左边的列查询，就不能用索引
      - 不能跳过索引中的列
      - 如果查询中有某个列的范围查询，则其右边所有列都不能使用索引优化查询

  - Hash索引

    - hash索引是基于hash表，只有精确匹配索引所有列的查询才能有效，存储引擎会给所有索引列计算一个哈希码，同时在hash表中存储指向数据行的指针。
    - 缺点
      1. hash表中不存储数据，所以不能避免读取数据行。
      2. 存储不是有序的。
      3. 不支持部分索引列查询。
      4. 可能产生hash冲突
      5. 只支持等值比较

  - 空间数据索引（R-tree）

    - MyISAM支持，他会从所有维度来索引数据

  - 全文索引

    - //todo

  - 索引的优点

    1. 大大减少服务器需要扫描的数据量
    2. 帮助服务器避免排序和临时表
    3. 可以将随机I/O改为顺序I/O

  - 高性能索引策略（如何更好的创建索引）

    - 判断列是否可以作为索引（索引的选择性）
      - 不重复的索引值和记录总数的比值（简单的来说就是一个字段中不重复的值的个数和全部个数的比值），越接近1越好。
    - 独立的列：索引列不能是函数或者表达式的一部分，即在索引列这边不能有其他的值，例如：WHERE id+1=2,这时mysql不能使用id索引列
    - 多列索引：5.0版本及以上，出现了”索引合并“策略
    - 选择合适索引顺序
      - 通常选择性较高的索引放在前面
    
  - #### 聚簇索引(数据存储类型)
  
    - 它并不是一种单独的索引类型，而是一种数据存储方式
    
    - 当表有聚簇索引时，他的数据是放在索引的“叶子页”中。
    
    - InnoDB存储引擎，是通过主键聚集数据，如果没有定义主键，那么存储引擎(InnoDB)会选择一个非NULL的索引来代替聚簇索引；如果没有这样的索引，会隐式的定义一个主键来代替聚簇索引。
    
    - 优点
      1. 可以把相关数据保存在一起(索引+数据)
      2. 数据访问更快
      3. 使用覆盖索引扫描的查询，可以直接使用页节点的主键值。
      
    - 缺点
    
      1. 聚簇索引最大限度地提高了IO密集型应用的性能，如果数据全在内存中，则访问的数据就没那么重要了，聚簇索引也就没什么优势了。
    
      2. InnoDB更新局促索引会将更新的行放到一个新的位置，代价很高。
    
      3. 聚簇索引插入新行或者主键被更新的时候会导致，行移动，可能导致“页分裂”
    
         “页分裂”：B-tree的一个节点的“页节点”满了，要插入一个新的行，会导致出现新的节点。即原本节点的页节点会分裂出去。
    
      4. 可能会导致全表扫描变慢
    
      5. 会导致二级索引变得很大
    
      6. 二级索引访问，会导致访问两次（第一次通过二级索引查到“主键值”，在通过主键值在聚簇索引里面找到目标数据）
    
  - ### 非聚簇索引（MyISAM）
  
    - 存储结构
  
      - MyISAM按照插入的顺序，将数据存放在磁盘上（自下而上）并在显示所对应的行号
  
        注意：并不是都加行号，要根据主键值是否是定长而定
  
      - ![1567825404003](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567825404003.png)
  
      - 对于主键之外的索引，存储方式和主键一样
  
  - ### 聚簇索引和非聚簇索引的区别
  
    - ![1567825590718](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567825590718.png)
    - 聚簇索引：不用回表查询数据，并且当移动行的时候，二级索引的“指针”不用更新。
    - 非聚簇索引：需要回表，当移动行的时候，二级索引也需要跟新。
    
  - 聚簇索引最好使用自增的主键；乱序的索引，会导致插入时有页分裂，过多的分裂，会产生数据碎片
  
- ### 覆盖索引

   - 包含或者覆盖目标字段的索引就是覆盖索引，这个索引包含着要查询的列和索引列，所以不需要回表查询
   - 注意：聚簇索引等价于覆盖索引，不完全是。（聚簇索引包含所有列）

- ### 索引和锁

- 维护索引和表

   1. 找到并修复损坏的表
   2. 更新索引统计信息
   3. 减少索引和数据的碎片

- ### 查询性能优化

   - 大概流程：客户端-服务器（解析-生成执行计划）-执行-返回给客户端

   - 慢查询的基础

      - 减少大量数据的查询(访问过多的行)

      - 减少服务器层分析大量超过需要的数据行

      - 避免多表关联式返回全部的数据列

         即：避免使用select * 

      - 避免重复查询相同的数据

   - 是否在扫描额外的记录

      - mysql衡量查询开销的指标：响应时间、扫描的行数、返回的行数
      - 当发现扫描大量的行，只返回少数时
         1. 使用索引覆盖扫描
         2. 改变表结构
         3. 重写这个查询

   - 重构查询

      - 一个复杂查询是否需要拆解成多个简单查询

      - 切分查询（当有一个数据过大的查询，可以进行小数据量多次查询的方式），减少对服务器的影响和对锁的把持

      - 分解关联查询

         - 例：假如有一个查询需要3个表的数据，不如将一个查询改成分别查询3个表所需要的字段。

         1. 叫缓存更高效
         2. 执行单个查询可以减少锁竞争
         3. 在应用层做关联，可以更容易对数据库拆分，更容易做到高效性和可扩展性
         4. 查询本身效率也会有提升
         5. 减少冗余记录的查询
         6. 更进一步，相当于再应用中实现了哈希关联，而不是多层嵌套循环

   - 执行查询的过程

      - ![1567910281230](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567910281230.png)
      - ![1567910408564](C:\Users\侯泽明\AppData\Roaming\Typora\typora-user-images\1567910408564.png)
      - 客户端和服务器的通信协议是“半双工”的
      
        

